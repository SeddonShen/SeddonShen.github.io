<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Rust 生命周期学习</title>
    <link href="/2023/03/23/Rust-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/03/23/Rust-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="Rust-生命周期学习"><a href="#Rust-生命周期学习" class="headerlink" title="Rust 生命周期学习"></a>Rust 生命周期学习</h1><p>Rust生命周期是Rust学习较为重要的一环，之前看过，但是看的不够深入，现在重新学习一下。</p><p>参考学习资料：<a href="https://course.rs/basic/lifetime.html">生命周期-Rust Course</a></p><p>生命周期，简而言之就是引用的有效作用域。在大多数时候，我们无需手动的声明生命周期，因为编译器可以自动进行推导，用类型来类比下：</p><p>就像编译器大部分时候可以自动推导类型 &lt;-&gt; 一样，编译器大多数时候也可以自动推导生命周期<br>在多种类型存在时，编译器往往要求我们手动标明类型 &lt;-&gt; 当多个生命周期存在，且编译器无法推导出某个引用的生命周期时，就需要我们手动标明生命周期</p><h2 id="悬垂指针和生命周期"><a href="#悬垂指针和生命周期" class="headerlink" title="悬垂指针和生命周期"></a>悬垂指针和生命周期</h2><p>生命周期主要是未来避免悬垂引用：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs rust">&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r</span>;<br><br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;<br>        r = &amp;x;<br>    &#125;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;r: &#123;&#125;&quot;</span>, r);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>let r; 貌似存在null的风险</li><li>r引用的x会在<code>&#125;</code>的时候释放，后面引用就无效了</li><li>这段代码会报错</li></ul><p>在这里 r 拥有更大的作用域，或者说活得更久。如果 Rust 不阻止该悬垂引用的发生，那么当 x 被释放后，r 所引用的值就不再是合法的，会导致我们程序发生异常行为，且该异常行为有时候会很难被发现。</p><h2 id="借用检查"><a href="#借用检查" class="headerlink" title="借用检查"></a>借用检查</h2><p>为了保证 Rust 的所有权和借用的正确性，Rust 使用了一个借用检查器(Borrow checker)，来检查我们程序的借用正确性：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-meta">#![allow(unused)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r</span>;                <span class="hljs-comment">// ---------+-- &#x27;a</span><br>                          <span class="hljs-comment">//          |</span><br>    &#123;                     <span class="hljs-comment">//          |</span><br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;        <span class="hljs-comment">// -+-- &#x27;b  |</span><br>        r = &amp;x;           <span class="hljs-comment">//  |       |</span><br>    &#125;                     <span class="hljs-comment">// -+       |</span><br>                          <span class="hljs-comment">//          |</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;r: &#123;&#125;&quot;</span>, r); <span class="hljs-comment">//          |</span><br>&#125;                         <span class="hljs-comment">// ---------+</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码和之前的一模一样，唯一的区别在于<strong>增加了对变量生命周期的注释</strong>。这里，r 变量被赋予了生命周期 ‘a，x 被赋予了生命周期 ‘b，从图示上可以明显看出生命周期 ‘b 比 ‘a 小很多。</p><p>在编译期，Rust 会比较两个变量的生命周期，结果发现 r 明明拥有生命周期 ‘a，但是却引用了一个小得多的生命周期 ‘b，在这种情况下，编译器会认为我们的程序存在风险，因此拒绝运行。</p><p>如果想要编译通过，也很简单，<strong>只要 ‘b 比 ‘a 大就好</strong>。总之，x 变量只要比 r 活得久，那么 r 就能随意引用 x 且不会存在危险：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><br><span class="hljs-meta">#![allow(unused)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>&#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">x</span> = <span class="hljs-number">5</span>;            <span class="hljs-comment">// ----------+-- &#x27;b</span><br>                          <span class="hljs-comment">//           |</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">r</span> = &amp;x;           <span class="hljs-comment">// --+-- &#x27;a  |</span><br>                          <span class="hljs-comment">//   |       |</span><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;r: &#123;&#125;&quot;</span>, r); <span class="hljs-comment">//   |       |</span><br>                          <span class="hljs-comment">// --+       |</span><br>&#125;                         <span class="hljs-comment">// ----------+</span><br>&#125;<br></code></pre></td></tr></table></figure><p>根据之前的结论，我们重新实现了代码，现在 x 的生命周期 ‘b 大于 r 的生命周期 ‘a，因此 r 对 x 的引用是安全的。</p><p>通过之前的内容，我们了解了何为生命周期，也了解了 Rust 如何利用生命周期来确保引用是合法的，下面来看看函数中的生命周期。</p><h2 id="函数中的生命周期"><a href="#函数中的生命周期" class="headerlink" title="函数中的生命周期"></a>函数中的生命周期</h2><p>先来考虑一个例子 - 返回两个字符串切片中较长的那个，该函数的参数是两个字符串切片，返回值也是字符串切片：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;abcd&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string2</span> = <span class="hljs-string">&quot;xyz&quot;</span>;<br><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">longest</span>(string1.<span class="hljs-title function_ invoke__">as_str</span>(), string2);<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The longest string is &#123;&#125;&quot;</span>, result);<br>&#125;<br><br><span class="hljs-meta">#![allow(unused)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>(x: &amp;<span class="hljs-type">str</span>, y: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">if</span> x.<span class="hljs-title function_ invoke__">len</span>() &gt; y.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        x<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        y<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>会报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs error">error[E0106]: missing lifetime specifier<br> --&gt; src/main.rs:9:33<br>  |<br>9 | fn longest(x: &amp;str, y: &amp;str) -&gt; &amp;str &#123;<br>  |               ----     ----     ^ expected named lifetime parameter // 参数需要一个生命周期<br>  |<br>  = help: this function&#x27;s return type contains a borrowed value, but the signature does not say whether it is<br>  borrowed from `x` or `y`<br>  = 帮助： 该函数的返回值是一个引用类型，但是函数签名无法说明，该引用是借用自 `x` 还是 `y`<br>help: consider introducing a named lifetime parameter // 考虑引入一个生命周期<br>  |<br>9 | fn longest&lt;&#x27;a&gt;(x: &amp;&#x27;a str, y: &amp;&#x27;a str) -&gt; &amp;&#x27;a str &#123;<br>  |           ^^^^    ^^^^^^^     ^^^^^^^     ^^^<br></code></pre></td></tr></table></figure><p>报错的问题主要是编译器无法知道该函数的返回值到底引用 x 还是 y ，因为编译器需要知道这些，来确保函数调用后的引用生命周期分析。</p><p>但是其实并不能知道到底是引用x还是引用y，因此，<strong>在存在多个引用时，编译器有时会无法自动推导生命周期，此时就需要我们手动去标注，通过为参数标注合适的生命周期来帮助编译器进行借用检查的分析。</strong></p><h2 id="生命周期的标注语法"><a href="#生命周期的标注语法" class="headerlink" title="生命周期的标注语法"></a>生命周期的标注语法</h2><p>生命周期标注并不会改变任何引用的实际作用域，标记的生命周期只是为了取悦编译器，让编译器不要难为我们。</p><p>例如一个变量，只能活一个花括号，那么就算你给它标注一个活全局的生命周期，它还是会在前面的花括号结束处被释放掉，并不会真的全局存活。</p><p>生命周期的语法也颇为与众不同，以 ‘ 开头，名称往往是一个单独的小写字母，大多数人都用 ‘a 来作为生命周期的名称。 如果是引用类型的参数，那么生命周期会位于引用符号 &amp; 之后，并用一个空格来将生命周期和引用参数分隔开:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![allow(unused)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>&amp;<span class="hljs-type">i32</span>        <span class="hljs-comment">// 一个引用</span><br>&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>     <span class="hljs-comment">// 具有显式生命周期的引用</span><br>&amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-keyword">mut</span> <span class="hljs-type">i32</span> <span class="hljs-comment">// 具有显式生命周期的可变引用</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一个生命周期标注，它自身并不具有什么意义，因为生命周期的作用就是告诉编译器多个引用之间的关系。例如，有一个函数，它的第一个参数 first 是一个指向 i32 类型的引用，具有生命周期 ‘a，该函数还有另一个参数 second，它也是指向 i32 类型的引用，并且同样具有生命周期 ‘a。此处生命周期标注仅仅说明，这两个参数 first 和 second 至少活得和’a 一样久，至于到底活多久或者哪个活得更久，抱歉我们都无法得知：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![allow(unused)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">useless</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(first: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>, second: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">i32</span>) &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="函数签名中的生命周期标注"><a href="#函数签名中的生命周期标注" class="headerlink" title="函数签名中的生命周期标注"></a>函数签名中的生命周期标注</h3><p>继续之前的 longest 函数，从两个字符串切片中返回较长的那个：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, y: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">if</span> x.<span class="hljs-title function_ invoke__">len</span>() &gt; y.<span class="hljs-title function_ invoke__">len</span>() &#123;<br>        x<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        y<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的点如下：</p><ul><li>和泛型一样，使用生命周期参数，需要先声明 &lt;’a&gt;</li><li>x、y 和返回值至少活得和 ‘a 一样久(因为返回值要么是 x，要么是 y)</li></ul><p>该函数签名表明对于某些生命周期 ‘a，函数的两个参数都至少跟 ‘a 活得一样久，同时函数的返回引用也至少跟 ‘a 活得一样久。实际上，这意味着返回值的生命周期与参数生命周期中的较小值一致：虽然两个参数的生命周期都是标注了 ‘a，但是实际上这两个参数的真实生命周期可能是不一样的(生命周期 ‘a 不代表生命周期等于 ‘a，而是<strong>大于等于</strong> ‘a)。</p><p><strong>在通过函数签名指定生命周期参数时，我们并没有改变传入引用或者返回引用的真实生命周期，而是告诉编译器当不满足此约束条件时，就拒绝编译通过。</strong></p><p>因此 longest 函数并不知道 x 和 y 具体会活多久，只要知道它们的作用域至少能持续 ‘a 这么长就行。</p><p>当把具体的引用传给 longest 时，那生命周期 ‘a 的大小就是 x 和 y 的作用域的重合部分，换句话说，’a 的大小将等于 x 和 y 中较小的那个。由于返回值的生命周期也被标记为 ‘a，因此返回值的生命周期也是 x 和 y 中作用域较小的那个。</p><p>例子：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;long string is long&quot;</span>);<br><br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">string2</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;xyz&quot;</span>);<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-title function_ invoke__">longest</span>(string1.<span class="hljs-title function_ invoke__">as_str</span>(), string2.<span class="hljs-title function_ invoke__">as_str</span>());<br>        <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The longest string is &#123;&#125;&quot;</span>, result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上例中，string1 的作用域直到 main 函数的结束，而 string2 的作用域到内部花括号的结束 }，那么根据之前的理论，’a 是两者中作用域较小的那个，也就是 ‘a 的生命周期等于 string2 的生命周期，同理，由于函数返回的生命周期也是 ‘a，可以得出函数返回的生命周期也等于 string2 的生命周期。</p><p>现在来验证下上面的结论：result 的生命周期等于参数中生命周期最小的，因此要等于 string2 的生命周期，也就是说，result 要活得和 string2 一样久，观察下代码的实现，可以发现这个结论是正确的！</p><p>因此，在这种情况下，通过生命周期标注，编译器得出了和我们肉眼观察一样的结论，而不再是一个蒙圈的大聪明。</p><p>再来看一个例子，该例子证明了 result 的生命周期必须等于两个参数中生命周期较小的那个:</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">string1</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;long string is long&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span>;<br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">string2</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;xyz&quot;</span>);<br>        result = <span class="hljs-title function_ invoke__">longest</span>(string1.<span class="hljs-title function_ invoke__">as_str</span>(), string2.<span class="hljs-title function_ invoke__">as_str</span>());<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;The longest string is &#123;&#125;&quot;</span>, result);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs error">error[E0597]: `string2` does not live long enough<br> --&gt; src/main.rs:6:44<br>  |<br>6 |         result = longest(string1.as_str(), string2.as_str());<br>  |                                            ^^^^^^^ borrowed value does not live long enough<br>7 |     &#125;<br>  |     - `string2` dropped here while still borrowed<br>8 |     println!(&quot;The longest string is &#123;&#125;&quot;, result);<br>  |                                          ------ borrow later used here<br></code></pre></td></tr></table></figure><p>在上述代码中，result 必须要活到 println!处，因为 result 的生命周期是 ‘a，因此 ‘a 必须持续到 println!。</p><p>在 longest 函数中，string2 的生命周期也是 ‘a，由此说明 string2 也必须活到 println! 处，可是 string2 在代码中实际上只能活到内部语句块的花括号处 }，小于它应该具备的生命周期 ‘a，因此编译出错。</p><p>作为人类，我们可以很清晰的看出 result 实际上引用了 string1，因为 string1 的长度明显要比 string2 长，既然如此，编译器不该如此矫情才对，它应该能认识到 result 没有引用 string2，让我们这段代码通过。只能说，作为尊贵的人类，编译器的发明者，你高估了这个工具的能力，它真的做不到！而且 Rust 编译器在调教上是非常保守的：当可能出错也可能不出错时，它会选择前者，抛出编译错误。</p><p>总之，显式的使用生命周期，可以让编译器正确的认识到多个引用之间的关系，最终帮我们提前规避可能存在的代码风险。</p><h3 id="深入思考生命周期标注"><a href="#深入思考生命周期标注" class="headerlink" title="深入思考生命周期标注"></a>深入思考生命周期标注</h3><p>使用生命周期的方式往往取决于函数的功能，例如之前的 longest 函数，如果它永远只返回第一个参数 x，生命周期的标注该如何修改？</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![allow(unused)]</span><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>, y: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>    x<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在此例中，y 完全没有被使用，因此 y 的生命周期与 x 和返回值的生命周期没有任何关系，意味着我们也不必再为 y 标注生命周期，只需要标注 x 参数和返回值即可。</p><p><strong>函数的返回值如果是一个引用类型，那么它的生命周期只会来源于：</strong></p><ul><li>函数参数的生命周期</li><li>函数体中某个新建引用的生命周期</li></ul><p>若是后者情况，就是典型的悬垂引用场景：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(x: &amp;<span class="hljs-type">str</span>, y: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span> &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;really long string&quot;</span>);<br>    result.<span class="hljs-title function_ invoke__">as_str</span>()<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的函数的返回值就和参数 x，y 没有任何关系，而是引用了函数体内创建的字符串，那么很显然，该函数会报错：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ERROR">error[E0515]: cannot return value referencing local variable `result` // 返回值result引用了本地的变量<br>  --&gt; src/main.rs:11:5<br>   |<br>11 |     result.as_str()<br>   |     ------^^^^^^^^^<br>   |     |<br>   |     returns a value referencing data owned by the current function<br>   |     `result` is borrowed here<br></code></pre></td></tr></table></figure><p>主要问题就在于，result 在函数结束后就被释放，但是在函数结束后，对 result 的引用依然在继续。在这种情况下，没有办法指定合适的生命周期来让编译通过，因此我们也就在 Rust 中避免了悬垂引用。</p><p>遇到这种情况的最好的解决方法是返回内部字符串的所有权，然后把字符串的所有权转移给调用者：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">longest</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt;(_x: &amp;<span class="hljs-type">str</span>, _y: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">String</span> &#123;<br>    <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;really long string&quot;</span>)<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>   <span class="hljs-keyword">let</span> <span class="hljs-variable">s</span> = <span class="hljs-title function_ invoke__">longest</span>(<span class="hljs-string">&quot;not&quot;</span>, <span class="hljs-string">&quot;important&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>至此，可以对生命周期进行下总结：生命周期语法用来将函数的多个引用参数和返回值的作用域关联到一起，一旦关联到一起后，Rust 就拥有充分的信息来确保我们的操作是内存安全的。</p><h2 id="结构体中的生命周期"><a href="#结构体中的生命周期" class="headerlink" title="结构体中的生命周期"></a>结构体中的生命周期</h2><p>不仅仅函数具有生命周期，结构体其实也有这个概念，只不过我们之前对结构体的使用都停留在非引用类型字段上。细心的同学应该能回想起来，之前为什么不在结构体中使用字符串字面量或者字符串切片，而是统一使用 String 类型？<strong>原因很简单，后者在结构体初始化时，只要转移所有权即可，而前者，抱歉，它们是引用，它们不能为所欲为。</strong></p><p>既然之前已经理解了生命周期，那么意味着在结构体中使用引用也变得可能：只要为结构体中的每一个引用标注上生命周期即可：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ImportantExcerpt</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    part: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">novel</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Call me Ishmael. Some years ago...&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">first_sentence</span> = novel.<span class="hljs-title function_ invoke__">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>).<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Could not find a &#x27;.&#x27;&quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">i</span> = ImportantExcerpt &#123;<br>        part: first_sentence,<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>ImportantExcerpt 结构体中有一个引用类型的字段 part，因此需要为它标注上生命周期。结构体的生命周期标注语法跟泛型参数语法很像，需要对生命周期参数进行声明 &lt;’a&gt;。该生命周期标注说明，结构体 ImportantExcerpt 所引用的字符串 str 必须比该结构体活得更久。</p><p>从 main 函数实现来看，ImportantExcerpt 的生命周期从第 4 行开始，到 main 函数末尾结束，而该结构体引用的字符串从第一行开始，也是到 main 函数末尾结束，可以得出结论结构体引用的字符串活得比结构体久，这符合了编译器对生命周期的要求，因此编译通过。</p><p>与之相反，下面的代码就无法通过编译：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs RUST"><span class="hljs-meta">#[derive(Debug)]</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ImportantExcerpt</span>&lt;<span class="hljs-symbol">&#x27;a</span>&gt; &#123;<br>    part: &amp;<span class="hljs-symbol">&#x27;a</span> <span class="hljs-type">str</span>,<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">i</span>;<br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">novel</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Call me Ishmael. Some years ago...&quot;</span>);<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">first_sentence</span> = novel.<span class="hljs-title function_ invoke__">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>).<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Could not find a &#x27;.&#x27;&quot;</span>);<br>        i = ImportantExcerpt &#123;<br>            part: first_sentence,<br>        &#125;;<br>    &#125;<br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,i);<br>&#125;<br></code></pre></td></tr></table></figure><p>观察代码，可以看出结构体比它引用的字符串活得更久，引用字符串在内部语句块末尾 } 被释放后，println! 依然在外面使用了该结构体，因此会导致无效的引用，不出所料，编译报错：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs RUST">error[E0597]: `novel` does not live long enough<br>  -<span class="hljs-punctuation">-&gt;</span> src/main.rs:<span class="hljs-number">10</span>:<span class="hljs-number">30</span><br>   |<br><span class="hljs-number">10</span> |         <span class="hljs-keyword">let</span> <span class="hljs-variable">first_sentence</span> = novel.<span class="hljs-title function_ invoke__">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>).<span class="hljs-title function_ invoke__">next</span>().<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Could not find a &#x27;.&#x27;&quot;</span>);<br>   |                              ^^^^^^^^^^^^^^^^ borrowed value does not live long enough<br>...<br><span class="hljs-number">14</span> |     &#125;<br>   |     - `novel` dropped here <span class="hljs-keyword">while</span> still borrowed<br><span class="hljs-number">15</span> |     <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;:?&#125;&quot;</span>,i);<br>   |                     - borrow later used here<br><br></code></pre></td></tr></table></figure><h2 id="生命周期消除"><a href="#生命周期消除" class="headerlink" title="生命周期消除"></a>生命周期消除</h2><p>未完待续…</p>]]></content>
    
    
    <categories>
      
      <category>Rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Rust</tag>
      
      <tag>生命周期</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用GPG对Github进行签名</title>
    <link href="/2023/03/11/%E4%BD%BF%E7%94%A8GPG%E5%AF%B9Github%E8%BF%9B%E8%A1%8C%E7%AD%BE%E5%90%8D/"/>
    <url>/2023/03/11/%E4%BD%BF%E7%94%A8GPG%E5%AF%B9Github%E8%BF%9B%E8%A1%8C%E7%AD%BE%E5%90%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在GitHub上面我们对自己提交的commit进行签名，通过签名之后GitHub就会知道这个commit是经过签名的、可信的commit，并且会有个绿色的“Verified”显示在旁边。</p><p>主要操作是安装PGP，以macOS下为例：</p><h1 id="安装GPG"><a href="#安装GPG" class="headerlink" title="安装GPG"></a>安装GPG</h1><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>gpg<br></code></pre></td></tr></table></figure><h1 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h1><h2 id="GPG版本-lt-2-1-17"><a href="#GPG版本-lt-2-1-17" class="headerlink" title="GPG版本&lt;2.1.17"></a>GPG版本&lt;2.1.17</h2><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs processing">gpg --<span class="hljs-keyword">default</span>-<span class="hljs-keyword">new</span>-<span class="hljs-built_in">key</span>-algo rsa4096 --gen-<span class="hljs-built_in">key</span><br></code></pre></td></tr></table></figure><h2 id="GPG版本-gt-x3D-2-1-17"><a href="#GPG版本-gt-x3D-2-1-17" class="headerlink" title="GPG版本&gt;&#x3D;2.1.17"></a>GPG版本&gt;&#x3D;2.1.17</h2><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs verilog">gpg --full-<span class="hljs-keyword">generate</span>-key<br></code></pre></td></tr></table></figure><h1 id="参数输入"><a href="#参数输入" class="headerlink" title="参数输入"></a>参数输入</h1><p>全部都可以默认，主要是填写邮箱的时候注意填写Github账户的邮箱。</p><h1 id="查看与导出"><a href="#查看与导出" class="headerlink" title="查看与导出"></a>查看与导出</h1><p>使用命令</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">gpg</span> <span class="hljs-literal">--</span><span class="hljs-comment">list</span><span class="hljs-literal">-</span><span class="hljs-comment">secret</span><span class="hljs-literal">-</span><span class="hljs-comment">keys</span> <span class="hljs-literal">--</span><span class="hljs-comment">keyid</span><span class="hljs-literal">-</span><span class="hljs-comment">format LONG</span><br></code></pre></td></tr></table></figure><p>从 GPG 密钥列表中复制想要使用的 GPG 密钥 ID。 在此例中，GPG 密钥 ID 是 3AA5C34371567BD2：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">gpg --list-secret-keys --keyid-format LONG<br><span class="hljs-section">/Users/hubot/.gnupg/secring.gpg</span><br><span class="hljs-section">------------------------------------</span><br>sec   4096R/3AA5C34371567BD2 2016-03-10 [expires: 2017-03-10]<br>uid                          Hubot <br>ssb   4096R/42B317FD4BA89E7A 2016-03-10<br></code></pre></td></tr></table></figure><p>导出要使用的密钥对，以此密钥为例</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">gpg</span> <span class="hljs-literal">--</span><span class="hljs-comment">armor</span> <span class="hljs-literal">--</span><span class="hljs-comment">export 3AA5C34371567BD2</span><br></code></pre></td></tr></table></figure><p>复制 GPG 密钥</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">从 -----<span class="hljs-keyword">BEGIN</span> PGP <span class="hljs-keyword">PUBLIC</span> KEY <span class="hljs-keyword">BLOCK</span>----- 开始<br>到 -----<span class="hljs-keyword">END</span> PGP <span class="hljs-keyword">PUBLIC</span> KEY <span class="hljs-keyword">BLOCK</span>----- 结束<br></code></pre></td></tr></table></figure><h1 id="添加密钥至-Github"><a href="#添加密钥至-Github" class="headerlink" title="添加密钥至 Github"></a>添加密钥至 Github</h1><p>在 Github 的设置中找到 SSH and GPG keys 选项，或点击链接：<a href="https://github.com/settings/keys">https://github.com/settings/keys</a></p><p>单击 New GPG key（新 GPG 密钥），然后粘贴上一步中复制的密钥</p><h1 id="使用密钥"><a href="#使用密钥" class="headerlink" title="使用密钥"></a>使用密钥</h1><p>在 Git 中设置 GPG 签名密钥，记得替换为自己的 GPG 密钥 ID</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">git<span class="hljs-built_in"> config </span>--global user.signingkey 3AA5C34371567BD2<br><span class="hljs-comment"># 为当前的单个项目配置密钥认证</span><br>git<span class="hljs-built_in"> config </span>commit.gpgsign <span class="hljs-literal">true</span><br><span class="hljs-comment"># 为全部项目配置密钥认证</span><br>git<span class="hljs-built_in"> config </span>--global commit.gpgsign <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><p>第一次commit会出现gpg无法正常签名的错误，需要安装pinentry-mac：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">error: </span>gpg failed to sign the data <br>fatal: failed to write commit object<br>##################<br><span class="hljs-keyword">error: </span>gpg 无法为数据签名<br>fatal: 无法写提交对象<br></code></pre></td></tr></table></figure><p>安装pinentry-mac：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">brew </span><span class="hljs-keyword">install </span>pinentry-mac<br></code></pre></td></tr></table></figure><p>新建配置文件并修改：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># 请注意，可能pinentry-mac安装位置有变化，请确定软件安装位置</span><br>pinentry-program <span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/bin/</span>pinentry-mac<br></code></pre></td></tr></table></figure><p>重启：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arduino">gpg-connect-agent reloadagent<br></code></pre></td></tr></table></figure><h1 id="参考与转载"><a href="#参考与转载" class="headerlink" title="参考与转载"></a>参考与转载</h1><p><a href="https://slw.im/2020/09/submit-to-github-with-gpg-on-mac/">在macOS上使用GPG对GitHub进行签名_灯半昏月半明</a></p><p><a href="https://morooi.com/2020/github-gpg/">在 macOS 中使用 GPG 签名提交至 Github_morooi’s Blog</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Cache包含策略</title>
    <link href="/2023/03/09/Cache%E5%8C%85%E5%90%AB%E7%AD%96%E7%95%A5/"/>
    <url>/2023/03/09/Cache%E5%8C%85%E5%90%AB%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="三种包含方式"><a href="#三种包含方式" class="headerlink" title="三种包含方式"></a>三种包含方式</h1><p>设计多级cache可以有很多种方式，可以根据一个cache的内容是否同时存在于其他级cache来分类，即Cache inclusion policy。</p><p>如果较低级别cache中的所有cacheline也存在于较高级别cache中，则称较高级别cache包含（inclusive ）较低级别cache。</p><p>如果较高级别的cache仅包含较低级别的cache中不存在的cacheline，则称较高级别的cache不包含（exclusive ）较低级别的cache。</p><p>如果较高级cache的内容既不严格包含也不排除较低级cache，则称为非包含非排他（non-inclusive non-exclusive ，NINE）cache。</p><h1 id="方式的比较"><a href="#方式的比较" class="headerlink" title="方式的比较"></a>方式的比较</h1><h2 id="inclusive-policy"><a href="#inclusive-policy" class="headerlink" title="inclusive policy"></a>inclusive policy</h2><p>优点在于：在每个处理器都具有私有cache 的并行系统中，如果存在cache miss，则检查其他私有cache以查找该cacheline。如果L2 cache包含L1 cache并且在L1 cache中miss，则不需要再搜索L1 cache。这意味着与inclusive cache和 NINE cache相比，inclusive cache的miss 延迟更短。</p><p>缺点是：cache的内存容量由L2 cache决定的。exclusive cache的容量是层次结构中所有cache的总容量。如果L2 cache较小，则在inclusive cache中浪费的cache容量更多。</p><h2 id="exclusive-policy"><a href="#exclusive-policy" class="headerlink" title="exclusive policy"></a>exclusive policy</h2><p>尽管exclusive cache具有更多的内存容量，但相比NINE cache，它需要占用更多的带宽，因为L1 cache evict时需要linefill数据到L2 cache。</p><p>因此，需要基于成本和收益评估，然后进行选择。</p><p>转载自知乎作者xpuu，写的比较详细：<a href="https://zhuanlan.zhihu.com/p/443090974">https://zhuanlan.zhihu.com/p/443090974</a></p>]]></content>
    
    
    <categories>
      
      <category>体系结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Cache</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP协议学习</title>
    <link href="/2023/01/20/HTTP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/01/20/HTTP%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="RESTful-API"><a href="#RESTful-API" class="headerlink" title="RESTful API"></a>RESTful API</h1><p>Representational State Transfer<br><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16742276226382.jpg"></p><h1 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h1><h2 id="最小单位—帧"><a href="#最小单位—帧" class="headerlink" title="最小单位—帧"></a>最小单位—帧</h2><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16742279025727.jpg"></p><h2 id="消息和数据流"><a href="#消息和数据流" class="headerlink" title="消息和数据流"></a>消息和数据流</h2><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16742279956434.jpg"></p><h2 id="新的特性"><a href="#新的特性" class="headerlink" title="新的特性"></a>新的特性</h2><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16742280728400.jpg"></p><h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16742288093686.jpg"></p><h1 id="优化与稳定"><a href="#优化与稳定" class="headerlink" title="优化与稳定"></a>优化与稳定</h1><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16742304495991.jpg"></p><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16742304905836.jpg"></p><h1 id="QUIC-优化传输体验（很有意义）"><a href="#QUIC-优化传输体验（很有意义）" class="headerlink" title="QUIC 优化传输体验（很有意义）"></a>QUIC 优化传输体验（很有意义）</h1><ul><li>目前还在研究阶段，应用还不是很多<br><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16742305412187.jpg"></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TypeScript入门学习</title>
    <link href="/2023/01/20/TypeScript%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/01/20/TypeScript%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="JS-和-TS"><a href="#JS-和-TS" class="headerlink" title="JS 和 TS"></a>JS 和 TS</h1><p>JS: 动态类型、弱类型语言<br>TS: 静态类型、弱类型语言</p><p>动态类型：在执行的时候才会去确定类型的匹配。在执行过程时进行类型匹配，才会匹配。<br>静态类型：提前做这个事情，例如Python。<br>弱类型语言：(str)1 + (int)1，  会做类型转换，是可以相加的。</p><h1 id="为什么使用TS？"><a href="#为什么使用TS？" class="headerlink" title="为什么使用TS？"></a>为什么使用TS？</h1><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16742083018741.jpg"></p><p>右边就是TS，左边是兼容的JS，主要是加一个类型。<br><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16742084571482.jpg"></p><h2 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h2><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16742085312311.jpg"></p><h2 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h2><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16742090196265.jpg"></p><h2 id="补充类型"><a href="#补充类型" class="headerlink" title="补充类型"></a>补充类型</h2><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16742091034265.jpg"></p><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16742091217906.jpg"></p><h2 id="高级数据类型"><a href="#高级数据类型" class="headerlink" title="高级数据类型"></a>高级数据类型</h2><h3 id="联合-x2F-交叉类型"><a href="#联合-x2F-交叉类型" class="headerlink" title="联合&#x2F;交叉类型"></a>联合&#x2F;交叉类型</h3><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16742097439032.jpg"></p><h3 id="类型保护与类型守卫"><a href="#类型保护与类型守卫" class="headerlink" title="类型保护与类型守卫"></a>类型保护与类型守卫</h3><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16742098812575.jpg"><br><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16742099313382.jpg"><br>PS:高级语法太多，建议有用到时看原视频重新学习。</p><h1 id="工程应用"><a href="#工程应用" class="headerlink" title="工程应用"></a>工程应用</h1><h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16742256575321.jpg"></p><ol><li>Webpack loader：把Webpack不能识别，Webpack主要处理js文件，比如把ts文件转为js文件。</li></ol><h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16742264281149.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>JS</tag>
      
      <tag>TypeScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端CSS基础-CSS深入2</title>
    <link href="/2023/01/18/%E5%89%8D%E7%AB%AFCSS%E5%9F%BA%E7%A1%80-CSS%E6%B7%B1%E5%85%A52/"/>
    <url>/2023/01/18/%E5%89%8D%E7%AB%AFCSS%E5%9F%BA%E7%A1%80-CSS%E6%B7%B1%E5%85%A52/</url>
    
    <content type="html"><![CDATA[<h1 id="布局方式-块级-vs-行级"><a href="#布局方式-块级-vs-行级" class="headerlink" title="布局方式 块级 vs. 行级"></a>布局方式 块级 vs. 行级</h1><p>CSS中的概念</p><table><thead><tr><th>块级box</th><th>行级box</th></tr></thead><tbody><tr><td>不和其他盒子并列摆放</td><td>和其他行级盒子一起放在一行 或 拆开成多行</td></tr><tr><td>适用所有的盒模型属性</td><td>盒模型中的width、height不适用</td></tr></tbody></table><p>HTML里面的概念，如Div，一般一个HTML标签生成啦一个box</p><table><thead><tr><th>块级<strong>元素</strong></th><th>行级<strong>元素</strong></th></tr></thead><tbody><tr><td>生成块级盒子</td><td>生成行级盒子、内容分散在多个行盒中</td></tr><tr><td>body、article、div、main、section、h1-6、p、ul、li等</td><td>盒span、em、strong、cite、code</td></tr><tr><td>display:block</td><td>display:inline</td></tr></tbody></table><h1 id="display-属性"><a href="#display-属性" class="headerlink" title="display 属性"></a>display 属性</h1><table><thead><tr><th>display</th><th>属性</th></tr></thead><tbody><tr><td>block</td><td>块级盒子</td></tr><tr><td>inline</td><td>行级盒子</td></tr><tr><td>inline-block</td><td>本身是行级，可以放在行盒中；可以设置宽高；作为一个整体不会被拆散成行</td></tr><tr><td>none</td><td>排版时完全忽略</td></tr></tbody></table><h1 id="行级排版上下文"><a href="#行级排版上下文" class="headerlink" title="行级排版上下文"></a>行级排版上下文</h1><p>注意：<strong>只包含行级盒子的容器会创建一个IFC</strong><br><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16740456092308.jpg"></p><h1 id="块级排版上下文"><a href="#块级排版上下文" class="headerlink" title="块级排版上下文"></a>块级排版上下文</h1><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16740467234870.jpg"></p><h2 id="排版规则"><a href="#排版规则" class="headerlink" title="排版规则"></a>排版规则</h2><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16740467588960.jpg"></p><h1 id="Flex-Box"><a href="#Flex-Box" class="headerlink" title="Flex Box"></a>Flex Box</h1><p>当容器内有很多的上下文，现在做布局多用的方式。<br><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16740470053942.jpg"></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>默认从左到右的流向。<br>可以控制流向、对齐等等排版内容。<br><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16740470536682.jpg"></p><h2 id="主轴和侧轴"><a href="#主轴和侧轴" class="headerlink" title="主轴和侧轴"></a>主轴和侧轴</h2><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16740471471190.jpg"></p><ul><li>主轴： 通过justify-content对齐<br><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16740471745611.jpg"></li><li>侧轴：通过align-items对齐<br>默认值是stretch（单词释义：撑大、拉紧）<br><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16740472475720.jpg"></li></ul><h2 id="Flex宽度和高度的计算（重要特性）"><a href="#Flex宽度和高度的计算（重要特性）" class="headerlink" title="Flex宽度和高度的计算（重要特性）"></a>Flex宽度和高度的计算（重要特性）</h2><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16740473398520.jpg"></p><p>下图：把剩余的空间按2:1分给a和b上。<br><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16740473562535.jpg"></p><h3 id="缩写属性"><a href="#缩写属性" class="headerlink" title="缩写属性"></a>缩写属性</h3><p>basis:不被压缩和拉伸的时候默认是100px，实际上平常都直接写宽度是100<br><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16740474448762.jpg"></p><h1 id="Grid布局"><a href="#Grid布局" class="headerlink" title="Grid布局"></a>Grid布局</h1><p>Flex主要是一条线，单一方向的布局方式，Grid偏向于二维。<br><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16740475147694.jpg"></p><h2 id="display-grid"><a href="#display-grid" class="headerlink" title="display: grid"></a>display: grid</h2><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16740477847007.jpg"></p><h2 id="划分网络"><a href="#划分网络" class="headerlink" title="划分网络"></a>划分网络</h2><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16740478814318.jpg"></p><p>第一种：分别设置列和行<br>第三种：最后fr：代表一份，100px除去后各占一份。</p><h2 id="grid-line-网格线"><a href="#grid-line-网格线" class="headerlink" title="grid line 网格线"></a>grid line 网格线</h2><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16740480003322.jpg"><br>表示这条黄色的线：<br>起始点 -&gt; 结束点 (1,1) -&gt; (3,3)</p><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16740480430314.jpg"></p><h1 id="绝对定位-position属性"><a href="#绝对定位-position属性" class="headerlink" title="绝对定位 position属性"></a>绝对定位 position属性</h1><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16740482693685.jpg"></p><h2 id="position-relative"><a href="#position-relative" class="headerlink" title="position: relative"></a>position: relative</h2><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16740483248107.jpg"></p><h2 id="position-absolute"><a href="#position-absolute" class="headerlink" title="position: absolute"></a>position: absolute</h2><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16740483584251.jpg"></p><h2 id="position-fixed"><a href="#position-fixed" class="headerlink" title="position: fixed"></a>position: fixed</h2><p>总是相对于视口去定位，特别适合做导航栏</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端CSS基础-CSS深入1</title>
    <link href="/2023/01/17/%E5%89%8D%E7%AB%AFCSS%E5%9F%BA%E7%A1%80-CSS%E6%B7%B1%E5%85%A51/"/>
    <url>/2023/01/17/%E5%89%8D%E7%AB%AFCSS%E5%9F%BA%E7%A1%80-CSS%E6%B7%B1%E5%85%A51/</url>
    
    <content type="html"><![CDATA[<h1 id="选择器特异度"><a href="#选择器特异度" class="headerlink" title="选择器特异度"></a>选择器特异度</h1><p>用于确定优先用哪个CSS属性。<br><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16739578792948.jpg"></p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16739581379181.jpg"><br>文字相关的一些是可以继承的，比如宽带等和盒模型有关系的就不可以继承了。</p><h2 id="显式继承"><a href="#显式继承" class="headerlink" title="显式继承"></a>显式继承</h2><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16739584149245.jpg"><br>要求所有元素的<code>box-sizing</code>都从父级元素继承。</p><h1 id="初始值"><a href="#初始值" class="headerlink" title="初始值"></a>初始值</h1><p>CSS中，每个属性都有一个初始值。<br><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16739590601940.jpg"></p><h1 id="CSS-求值过程"><a href="#CSS-求值过程" class="headerlink" title="CSS 求值过程"></a>CSS 求值过程</h1><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16739591108817.jpg"><br><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16739597241872.jpg"></p><h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><ul><li>确定内容的大小和位置的算法。</li><li>依据元素、容器、兄弟节点和内容等信息来计算。</li></ul><h2 id="布局相关技术"><a href="#布局相关技术" class="headerlink" title="布局相关技术"></a>布局相关技术</h2><ul><li>常规流 （一些常规的流）行级、块级、表格布局、FlexBox、Grid布局</li><li>浮动 </li><li>绝对定位</li></ul><h2 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h2><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16739600993898.jpg"></p><h3 id="循环依赖"><a href="#循环依赖" class="headerlink" title="循环依赖"></a>循环依赖</h3><p>比如父级用<code>auto</code>指定了宽度或者高度（依赖子级），但是本级设置的宽度或高度使用的是百分比（依赖父级）这样就无法正确计算，因为产生了循环依赖。</p><h3 id="padding"><a href="#padding" class="headerlink" title="padding"></a>padding</h3><ul><li>百分数相对于元素宽度</li></ul><h3 id="border-边框"><a href="#border-边框" class="headerlink" title="border 边框"></a>border 边框</h3><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16739605431910.jpg"></p><p>边框颜色不一样会斜着切过来。<br><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16739605678695.jpg"></p><p>把其他三边设置透明，可以得到三角形。</p><h3 id="margin-外边距"><a href="#margin-外边距" class="headerlink" title="margin 外边距"></a>margin 外边距</h3><p>设置水平居中。</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-attribute">margin-left</span>: auto<br>margin-right: auto<br></code></pre></td></tr></table></figure><h3 id="margin-collapse"><a href="#margin-collapse" class="headerlink" title="margin collapse"></a>margin collapse</h3><p>上面的下边距100px和下面的上边距100px。<br>则中间是100px，而不是200px。<br>外边距事实上会进行折叠，会选择两者中最大的值。</p><h2 id="box-sizing-border-box"><a href="#box-sizing-border-box" class="headerlink" title="box-sizing: border-box"></a>box-sizing: border-box</h2><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16739613857029.jpg"><br>使用border来作为宽度。<br>实际效果对比：<br><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/21/16739614180966.jpg"></p><h2 id="overflow处理"><a href="#overflow处理" class="headerlink" title="overflow处理"></a>overflow处理</h2><p>虽然设置了box的宽高，但实际上内部内容仍然可能溢出。可以设置</p><ul><li>visible</li><li>hidden</li><li>scroll（滚动）</li><li>auto</li></ul><p>四种属性</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端CSS基础回顾</title>
    <link href="/2023/01/16/%E5%89%8D%E7%AB%AFCSS%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/"/>
    <url>/2023/01/16/%E5%89%8D%E7%AB%AFCSS%E5%9F%BA%E7%A1%80%E5%9B%9E%E9%A1%BE/</url>
    
    <content type="html"><![CDATA[<p>字节寒假青训营重新补一下基础的CSS，看看有没有什么新的发现。<br>课程链接：<br><a href="https://juejin.cn/course/bytetech/7145675320224383006/section/7145716268698435620">https://juejin.cn/course/bytetech/7145675320224383006/section/7145716268698435620</a></p><h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><ul><li>选择器</li><li>属性</li><li>属性值<br><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/16/16738767222914.jpg"></li></ul><p>在页面中使用CSS的方法：</p><ul><li>外链 <code>&lt;link&gt;</code> 标签（最推荐） 有一个功能的分工</li><li>嵌入 <code>&lt;style&gt;&lt;style&gt;</code></li><li>内联 <code>&lt;p style=&quot;&quot;&gt;&lt;/p&gt;</code>（较不推荐）</li></ul><h1 id="CSS工作流程"><a href="#CSS工作流程" class="headerlink" title="CSS工作流程"></a>CSS工作流程</h1><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/16/16738772168977.jpg"><br>加载和解析HTML后，会创建DOM树，同时加载解析CSS，把样式添加到DOM树中，得到所谓的渲染树，最后展示页面。</p><h1 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h1><p>找出页面中的元素，以便设置样式。<br>标签名、类名、id、属性、DOM树位置。<br>需要注意**统配选择器 ***</p><h2 id="根据属性特定的值做匹配"><a href="#根据属性特定的值做匹配" class="headerlink" title="根据属性特定的值做匹配"></a>根据属性特定的值做匹配</h2><p>只选中type是password的input<br><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/16/16738775074347.jpg"></p><p>匹配以#开头、以.jpg结尾的href属性<br><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/16/16738775667883.jpg"></p><h1 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h1><p>不基于标签和属性定位元素<br>类别：</p><ul><li>状态伪类</li><li>结构性伪类</li></ul><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs css">&lt;style&gt;<br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:link</span> &#123;<br>    <span class="hljs-comment">/* 默认链接状态等*/</span><br>    <span class="hljs-attribute">color</span>: black;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:visited</span> &#123;<br>    <span class="hljs-comment">/* 访问过*/</span><br>    <span class="hljs-attribute">color</span>: black;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<br>    <span class="hljs-comment">/* 鼠标放上去*/</span><br>    <span class="hljs-attribute">color</span>: black;<br>&#125;<br><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:active</span> &#123;<br>    <span class="hljs-comment">/* 被点过之后*/</span><br>    <span class="hljs-attribute">color</span>: black;<br>&#125;<br><span class="hljs-selector-pseudo">:focus</span> &#123;<br>    <span class="hljs-comment">/* 用于输入框被focus等*/</span><br>    <span class="hljs-attribute">color</span>: black;<br>&#125;<br><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:first</span>-child&#123;<br><span class="hljs-comment">/* li的第一个孩子*/</span><br>&#125;<br><span class="hljs-selector-tag">li</span><span class="hljs-selector-pseudo">:last-child</span>&#123;<br><span class="hljs-comment">/* li的第最后一个孩子*/</span><br>&#125;<br>&lt;/style&gt;<br></code></pre></td></tr></table></figure><h1 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h1><p>常见组合：</p><ul><li>直接组合 AB</li><li>后代组合 A B</li><li>亲子组合 A &gt; B</li><li>兄弟选择器 A ~ B</li><li>相邻选择器 A + B<br><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/16/16738794305900.jpg"></li></ul><h1 id="颜色"><a href="#颜色" class="headerlink" title="颜色"></a>颜色</h1><h2 id="HSL"><a href="#HSL" class="headerlink" title="HSL"></a>HSL</h2><p>RGB难以直接看出颜色，可以使用HSL颜色表示进行方便的调试。<br> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs css">hsl(<span class="hljs-number">211</span>,<span class="hljs-number">66%</span>,<span class="hljs-number">50%</span>)<br></code></pre></td></tr></table></figure></p><h2 id="直接指定值"><a href="#直接指定值" class="headerlink" title="直接指定值"></a>直接指定值</h2><p> black、white等</p><h2 id="Alpha透明度"><a href="#Alpha透明度" class="headerlink" title="Alpha透明度"></a>Alpha透明度</h2><p> 实际上是不透明度，alpha为1的时候是不透明的。<br> <figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">rgba(<span class="hljs-number">255</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0.47</span>)<br>hsla(<span class="hljs-number">0</span>,<span class="hljs-number">100%</span>,<span class="hljs-number">50%</span>,<span class="hljs-number">0.47</span>)<br></code></pre></td></tr></table></figure></p><h1 id="字体-font-family"><a href="#字体-font-family" class="headerlink" title="字体 font-family"></a>字体 font-family</h1><h2 id="通用字体"><a href="#通用字体" class="headerlink" title="通用字体"></a>通用字体</h2><p> serif：衬线体<br> sans-serif：无衬线体<br> Monospace：等宽字体（Coding常用）<br><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/16/16738801965413.jpg"><br>小技巧：混排中英文时，英文字体写在中文字体前面。<br>也可以使用Webfont，中文字体较大，通常裁切。</p><h2 id="font-size"><a href="#font-size" class="headerlink" title="font-size"></a>font-size</h2><p>单位：px,em(相对单位 和上级相乘)</p><h2 id="font-weight"><a href="#font-weight" class="headerlink" title="font-weight"></a>font-weight</h2><p>字重 100 ～ 900 就是字的粗细<br>注： 400是normal 700是bold<br>显示没效果可能是字体不适配。</p><h2 id="line-height"><a href="#line-height" class="headerlink" title="line-height"></a>line-height</h2><p>行高，默认多行字体都要改一下。<br><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/16/16738803968202.jpg"></p><h2 id="text-align"><a href="#text-align" class="headerlink" title="text-align"></a>text-align</h2><ul><li>居中、左、右</li><li><code>text-align:justify</code> 分散对齐（可能最后一行就不生效了哈，毕竟那样很丑）</li></ul><h1 id="空白符的处理（易错）"><a href="#空白符的处理（易错）" class="headerlink" title="空白符的处理（易错）"></a>空白符的处理（易错）</h1><p>多个连续的换行、空格默认会被替换为一个。<br>white-space</p><ul><li>nowrap</li><li>pre</li><li>pre-warp</li><li>pre-line 保留换行和空格 ······</li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V 模拟器集锦</title>
    <link href="/2023/01/12/RISC-V-%E6%A8%A1%E6%8B%9F%E5%99%A8%E9%9B%86%E9%94%A6/"/>
    <url>/2023/01/12/RISC-V-%E6%A8%A1%E6%8B%9F%E5%99%A8%E9%9B%86%E9%94%A6/</url>
    
    <content type="html"><![CDATA[<p>汇总一下，可以作为之后调试使用的一些内容。</p><ul><li>QEMU </li><li>NEMU (南京大学)</li><li>Rare (<a href="https://siriusdemon.github.io/Rare/v10-Page-Table.html">https://siriusdemon.github.io/Rare/v10-Page-Table.html</a>)</li><li>tinyemu (由 QEMU 的作者 Fabrice Bellard 所写 开源小型 易于理解 <a href="https://bellard.org/tinyemu/">https://bellard.org/tinyemu/</a>)</li></ul>]]></content>
    
    
    <categories>
      
      <category>体系结构</category>
      
      <category>操作系统</category>
      
      <category>模拟器</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISC-V</tag>
      
      <tag>Emulator</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V 虚拟内存机制随笔</title>
    <link href="/2023/01/12/RISC-V-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E9%9A%8F%E7%AC%94/"/>
    <url>/2023/01/12/RISC-V-%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<h1 id="相关知识"><a href="#相关知识" class="headerlink" title="相关知识"></a>相关知识</h1><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p><p>通过内存地址虚拟化，可以使得软件在没有访问某虚拟内存地址时不分配具体的物理内存，而只有在实际访问某虚拟内存地址时，操作系统再动态地分配物理内存，建立虚拟内存到物理内存的页映射关系，这种技术称为按需分页（demand paging）。把不经常访问的数据所占的内存空间临时写到硬盘上，这样可以腾出更多的空闲内存空间给经常访问的数据；当CPU访问到不经常访问的数据时，再把这些数据从硬盘读入到内存中，这种技术称为页换入换出（page swap in&#x2F;out）。这种内存管理技术给了程序员更大的内存“空间”，从而可以让更多的程序在内存中并发运行。</p><h2 id="内存管理单元MMU"><a href="#内存管理单元MMU" class="headerlink" title="内存管理单元MMU"></a>内存管理单元MMU</h2><p>MMU（Memory Management Unit）是一种负责处理中央处理器（CPU）的内存访问请求的计算机硬件。它的功能包括虚拟地址到物理地址的转换（即虚拟内存管理）、内存保护、中央处理器高速缓存的控制。</p><p>MMU位于处理器内核和连接高速缓存以及物理存储器的总线之间。如果处理器没有MMU，CPU内部执行单元产生的内存地址信号将直接通过地址总线发送到芯片引脚，被内存芯片接收，这就是物理地址。</p><p>如果MMU存在且启用，CPU执行单元产生的地址信号在发送到内存芯片之前将被MMU截获，这个地址信号称为虚拟地址，MMU会负责把虚拟地址翻译成相应的物理地址，然后发到内存芯片地址引脚上。<strong>简而言之，当处理器内核取指令或者存取数据的时候，会提供一个虚拟地址，这个地址是可执行代码在编译的时候由链接器生成的。MMU负责将虚拟地址转换为物理地址，以在物理存储器中访问相应的内容。</strong></p><h2 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h2><p>分页机制的基本思想是将程序的虚拟地址空间划分为连续的，等长的虚拟页。虚拟页和物理页的页长固定且相等（一般情况下为4KB），从而操作系统可以方便的为每个程序构造页表，即虚拟页到物理页的映射关系。逻辑上，该机制下的虚拟地址有两个部分组成：1.虚拟页号；2.页内偏移。在具体的翻译过程中，MMU首先解析得到虚拟地址中的虚拟页号，并通过虚拟页号查找到对应的物理页，用该物理页的起始地址加上页内偏移得到最终的物理地址。</p><h1 id="操作系统的实际转换流程"><a href="#操作系统的实际转换流程" class="headerlink" title="操作系统的实际转换流程"></a>操作系统的实际转换流程</h1><p>当程序（操作系统）在M特权级初始化完成后，CPU将跳转到内核入口点并在S特权级上执行，此时还并没有开启分页模式，<strong>内核的每次访存是直接的物理内存访问</strong>。</p><p>而在开启分页模式之后，内核代码在访存时只能看到内核地址空间，此时每次访存需要通过 MMU 的地址转换。这两种模式之间的过渡在内核初始化期间完成。</p><p>按照 satp CSR 格式要求 构造一个无符号 64 位无符号整数，使得其分页模式为 SV39 ，且将当前多级页表的根节点所在的物理页号填充进去。在 activate 中，我们将这个值写入当前 CPU 的 satp CSR ，从这一刻开始 SV39 分页模式就被启用了，而且 MMU 会使用内核地址空间的多级页表进行地址转换。</p><pre><code class="hljs">摘自Rcore实验指导：我们必须注意切换 satp CSR 是否是一个 平滑 的过渡：其含义是指，切换 satp 的指令及其下一条指令这两条相邻的指令的虚拟地址是相邻的（由于切换 satp 的指令并不是一条跳转指令， pc 只是简单的自增当前指令的字长），而它们所在的物理地址一般情况下也是相邻的，但是它们所经过的地址转换流程却是不同的——切换 satp 导致 MMU 查的多级页表是不同的。这就要求前后两个地址空间在切换 satp 的指令 附近 的映射满足某种意义上的连续性。    </code></pre><h1 id="地址转换"><a href="#地址转换" class="headerlink" title="地址转换"></a>地址转换</h1><p>Sv39的转换即为下图：<br><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/12/16735103436281.jpg"><br><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/12/16735104088393.jpg"></p><p>注：可深入阅读Rare[3]中的相关过程，会有更深的理解。</p><p>详见The RISC-V Instruction Set Manual, Volume II: Privileged Architecture<br>4.3 4.4 节</p><p>相关资料来自：</p><ul><li>[1] Rcore实验指导书 <a href="http://wyfcyx.gitee.io/rcore-tutorial-book-v3/chapter4/6multitasking-based-on-as.html">http://wyfcyx.gitee.io/rcore-tutorial-book-v3/chapter4/6multitasking-based-on-as.html</a></li><li>[2] 知乎作者 水dong方块 <a href="https://www.zhihu.com/question/25628124/answer/2308945192">https://www.zhihu.com/question/25628124/answer/2308945192</a></li><li>[3] Rare: Rust A Riscv Emulator <a href="https://siriusdemon.github.io/Rare/v10-Page-Table.html">https://siriusdemon.github.io/Rare/v10-Page-Table.html</a></li><li>[4] The RISC-V Instruction Set Manual, Volume II: Privileged Architecture <a href="http://www.five-embeddev.com/riscv-isa-manual/latest/supervisor.html#sv32algorithm">http://www.five-embeddev.com/riscv-isa-manual/latest/supervisor.html#sv32algorithm</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>体系结构</category>
      
      <category>操作系统</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISC-V</tag>
      
      <tag>CSR</tag>
      
      <tag>虚拟内存</tag>
      
      <tag>MMU</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Javascript 事件循环</title>
    <link href="/2023/01/06/Javascript-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/"/>
    <url>/2023/01/06/Javascript-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/</url>
    
    <content type="html"><![CDATA[<p>事件循环：Javascript是单线程的，但是又需要一种机制来处理多个块的执行。</p><p>且执行每个块时调用Javascript引擎，这种机制称为事件循环，与事件绑定概念毫无关系。</p><p>事件循环分了部分：主线程、宏队列、微队列，异步代码都会被丢进宏&#x2F;微队列</p><ul><li>宏任务：script, setTimeout, setInterval, setImmediate, I&#x2F;0, UI rendering</li><li>微任务：process.nextTick, promise. then(), object.observe, Mutationobserver</li></ul><p>主线程只有一个，且执行顺序为：</p><ul><li>1、先执行主线程</li><li>2、遇到宏任务放到宏队列</li><li>3、遇到微任多放到微队列</li><li>4、主线程执行完毕</li><li>5、优先执行微队列，微队列执行完毕</li><li>6、执行一次宏队列的任务，执行完毕</li><li>7、执行微队列，执行完毕</li><li>8、依次循环。。</li></ul><p>两个队列可以理解为两个数组，不停执行两个数组里面的东西，空了就不执行。</p><p>比较通俗的理解： <a href="https://www.bilibili.com/video/BV1om4y1F7jb">https://www.bilibili.com/video/BV1om4y1F7jb</a></p><p>练习题参考：<a href="https://juejin.cn/pin/7183132179717685307">https://juejin.cn/pin/7183132179717685307</a></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>同步</tag>
      
      <tag>异步</tag>
      
      <tag>事件循环</tag>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端学习 Web布局</title>
    <link href="/2023/01/04/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0-Web%E5%B8%83%E5%B1%80/"/>
    <url>/2023/01/04/%E5%89%8D%E7%AB%AF%E5%AD%A6%E4%B9%A0-Web%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="前端学习-Web布局"><a href="#前端学习-Web布局" class="headerlink" title="前端学习 Web布局"></a>前端学习 Web布局</h1><p>块级元素、行内元素、行内块级元素。<br><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/05/16728440189745.jpg">g<br><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/05/16728445105161.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V 中断和异常的一些参考资料</title>
    <link href="/2022/12/15/RISC-V-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/"/>
    <url>/2022/12/15/RISC-V-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%82%E8%80%83%E8%B5%84%E6%96%99/</url>
    
    <content type="html"><![CDATA[<p>近期罹患COVID-19，暂未更新博客内容，阅读了一些较为不错的资料，通过此篇文章进行收藏，作为学习和相关文章撰写的一些资料参考。</p><p><a href="https://zhuanlan.zhihu.com/p/461722132">RISC-V的中断和异常（含详细过程）</a></p><p>不定期更新……</p>]]></content>
    
    
    <categories>
      
      <category>体系结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISC-V</tag>
      
      <tag>CSR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V 特权指令的一些随笔</title>
    <link href="/2022/12/10/RISC-V-%E7%89%B9%E6%9D%83%E6%8C%87%E4%BB%A4%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9A%8F%E7%AC%94/"/>
    <url>/2022/12/10/RISC-V-%E7%89%B9%E6%9D%83%E6%8C%87%E4%BB%A4%E7%9A%84%E4%B8%80%E4%BA%9B%E9%9A%8F%E7%AC%94/</url>
    
    <content type="html"><![CDATA[<h2 id="三个模式相互切换的操作"><a href="#三个模式相互切换的操作" class="headerlink" title="三个模式相互切换的操作"></a>三个模式相互切换的操作</h2><p>部分摘自：<a href="https://blog.csdn.net/m0_67403188/article/details/126080659">https://blog.csdn.net/m0_67403188/article/details/126080659</a><br><img src="https://img-blog.csdnimg.cn/5473a6dd24d445779c72fe06e891563a.png"></p><h2 id="MStatus"><a href="#MStatus" class="headerlink" title="MStatus"></a>MStatus</h2><p>当使用mret从trap中返回。会根据MPP的值来确定返回的新的特权模式，然后硬件改写mstatus中的MPP&#x3D;0，MIE&#x3D;MPIE，MPIE&#x3D;进trap前的MIE，并设置PC&#x3D;MEPC。</p><h2 id="MCause"><a href="#MCause" class="headerlink" title="MCause"></a>MCause</h2><p>Machine Cause Register寄存器是一个mxlen位的读写寄存器。当一个trap被带入m模式时，mcause被硬件写入一个代码，指示导致该trap的事件。如果trap是由中断引起的，则设置mcause寄存器中的中断bit位。</p><h2 id="MTVEC"><a href="#MTVEC" class="headerlink" title="MTVEC"></a>MTVEC</h2><p>MTVEC用于存储Trap处理程序的地址。就是存储中断向量表的基地址。<br>当MODE&#x3D;Direct时，所有进入机器模式的trap都会导致pc被设置为BASE字段中的地址。当MODE&#x3D; vector时，所有进入机器模式的同步异常都会导致pc被设置为BASE字段中的地址，而异步中断会导致pc被设置为BASE字段中的地址加上中断cause数的四倍。</p><h2 id="MEPC（Machine-Exception-Program-Counter）"><a href="#MEPC（Machine-Exception-Program-Counter）" class="headerlink" title="MEPC（Machine Exception Program Counter）"></a>MEPC（Machine Exception Program Counter）</h2><p>它保存导致trap的指令的地址。</p><h2 id="MIE"><a href="#MIE" class="headerlink" title="MIE"></a>MIE</h2><p>中断使能寄存器，区别于mstatus.MIE作为全局控制，MIE是局部控制。<br>MEIE：M模式外部中断使能位<br>SEIE：S模式外部中断使能位<br>MTIE：M模式timer中断使能位<br>STIE：S模式外部中断使能位<br>MSIE：M模式软中断使能位<br>SSIE：S模式软中断使能位</p><h2 id="MIP"><a href="#MIP" class="headerlink" title="MIP"></a>MIP</h2><p>中断挂起寄存器，包含关于挂起中断的信息。<br>原文博主的理解：当正在处理一个中断，并且mie关掉中断时，同时设置了mip，此时产生了另一个中断则其会被pending，则MIP里对应的中断信息会被记录。（多个中断？）<br>MEIP：M模式外部中断挂起位<br>SEIP：S模式外部中断挂起位<br>MTIP：M模式timer中断挂起位<br>STIP：S模式外部中断挂起位<br>MSIP：M模式软中断挂起位<br>SSIP：S模式软中断挂起位</p><h2 id="MSCRATCH"><a href="#MSCRATCH" class="headerlink" title="MSCRATCH"></a>MSCRATCH</h2><p>mscratch 寄存器用于机器模式下的程序临时保存某些数据。mscratch 寄存器可以提供一<br>种快速的保存和恢复机制。譬如，在进入机器模式的异常处理程序后，将应用程序的某个通<br>用寄存器的值临时存入 mscratch 寄存器中，然后在退出异常处理程序之前，将 mscratch 寄<br>存器中的值读出恢复至通用寄存器。</p>]]></content>
    
    
    <categories>
      
      <category>体系结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISC-V</tag>
      
      <tag>CSR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于RiscVTests实验过程中的一些记录</title>
    <link href="/2022/12/04/%E5%85%B3%E4%BA%8ERiscVTests%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/12/04/%E5%85%B3%E4%BA%8ERiscVTests%E5%AE%9E%E9%AA%8C%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<h1 id="rv32mi"><a href="#rv32mi" class="headerlink" title="rv32mi"></a>rv32mi</h1><h2 id="rv32mi-breakpoint-hex"><a href="#rv32mi-breakpoint-hex" class="headerlink" title="rv32mi-breakpoint.hex"></a>rv32mi-breakpoint.hex</h2><p>由于未实现tselect寄存器（实现为0），因此该Test直接通过，后续需要进行修改。</p><h2 id="失败"><a href="#失败" class="headerlink" title="失败"></a>失败</h2><ul><li>should pass rv32mi-csr.hex *** FAILED ***</li><li>should pass rv32mi-illegal.hex *** FAILED ***</li><li>should pass rv32mi-ma_addr.hex *** FAILED ***</li><li>should pass rv32mi-ma_fetch.hex *** FAILED ***</li><li>should pass rv32mi-sbreak.hex *** FAILED ***</li><li>should pass rv32mi-scall.hex *** FAILED ***</li><li>should pass rv32mi-shamt.hex *** FAILED ***</li></ul><h2 id="成功"><a href="#成功" class="headerlink" title="成功"></a>成功</h2><ul><li>should pass rv32mi-mcsr.hex</li></ul>]]></content>
    
    
    <categories>
      
      <category>体系结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISC-V</tag>
      
      <tag>CSR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V 寄存器与ABI名称</title>
    <link href="/2022/11/28/RISC-V-%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8EABI%E5%90%8D%E7%A7%B0/"/>
    <url>/2022/11/28/RISC-V-%E5%AF%84%E5%AD%98%E5%99%A8%E4%B8%8EABI%E5%90%8D%E7%A7%B0/</url>
    
    <content type="html"><![CDATA[<p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/06/reglist.png" alt="reglist"></p>]]></content>
    
    
    <categories>
      
      <category>体系结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISC-V</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scala 伴生对象</title>
    <link href="/2022/11/19/Scala-%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1/"/>
    <url>/2022/11/19/Scala-%E4%BC%B4%E7%94%9F%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<p>在Scala中，类和对象可以共享同一个名称。</p><p>当一个对象与一个类共享一个名称时，它被称为伴生对象，并且该类被称为伴生类。</p><p>伴生对象是与另一个类或特征共享相同名称和源文件的对象。（需要在一个文件下）</p><p>一个trait可以看作是一个Java接口。</p><p>这种方法允许我们在类上创建静态成员。</p><p>伴生对象对实现辅助方法和工厂很有用。</p><p>要实现一个创建不同类型的形状的工厂，我们可以在Scala中创建一个形状工厂。</p><p>类和它的伴生对象可以互相访问其私有成员。</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>我们使用一个伴生类Shape和一个伴生对象Shape，作为一个工厂。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">trait</span> <span class="hljs-title">Shape</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">area</span> </span>:<span class="hljs-type">Double</span><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Shape</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span>(<span class="hljs-params">radius: <span class="hljs-type">Double</span></span>) <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span></span>&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> area = <span class="hljs-number">3.14</span>*radius*radius<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> (<span class="hljs-params">height: <span class="hljs-type">Double</span>, length: <span class="hljs-type">Double</span></span>)<span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span></span>&#123;<br>        <span class="hljs-keyword">override</span> <span class="hljs-keyword">val</span> area = height * length<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(height :<span class="hljs-type">Double</span> , length :<span class="hljs-type">Double</span> ) : <span class="hljs-type">Shape</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">Rectangle</span>(height,length)<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(radius :<span class="hljs-type">Double</span>) : <span class="hljs-type">Shape</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">Circle</span>(radius)<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Main</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">App</span> </span>&#123;<br>    <span class="hljs-keyword">val</span> circle = <span class="hljs-type">Shape</span>(<span class="hljs-number">2</span>)<br>    println(circle.area)<br>    <span class="hljs-keyword">val</span> rectangle = <span class="hljs-type">Shape</span>(<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)<br>    println(rectangle.area)<br>&#125;<br></code></pre></td></tr></table></figure><p>更直观的例子：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Companion</span> </span>&#123;<br>  <span class="hljs-comment">// 伴生类 和 伴生对象</span><br>  <span class="hljs-comment">//    1、class和object在同一个scala文件中</span><br>  <span class="hljs-comment">//    2、class和object要同名</span><br>  <span class="hljs-comment">// 特征：</span><br>  <span class="hljs-comment">//    1、伴生类和伴生对象可互访私有成员</span><br>  <span class="hljs-comment">//    2、伴生对象 的apply方法，可简化 伴生类之对象 的创建</span><br>  <span class="hljs-comment">// 感性认识：</span><br>  <span class="hljs-comment">//    class里面的全是 非静态的，object里面的全是 静态的</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>    <span class="hljs-keyword">val</span> person = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span><br>    <span class="hljs-comment">//    print(person.name)</span><br>    <span class="hljs-comment">//    print(person.age)</span><br>    println(<span class="hljs-type">Person</span>.param)<br>    <span class="hljs-comment">//    Person.add()</span><br><br>    println(person.sum(<span class="hljs-number">11</span>, <span class="hljs-number">22</span>))<br><br>    <span class="hljs-type">Person</span>.printAge<br><br>    <span class="hljs-keyword">val</span> p1: <span class="hljs-type">Person</span> = <span class="hljs-type">Person</span>.apply()<br>    <span class="hljs-keyword">val</span> p2: <span class="hljs-type">Person</span> = <span class="hljs-type">Person</span>() <span class="hljs-comment">// 相当于 Person.apply()</span><br>  &#125;<br>&#125;<br><br><span class="hljs-comment">//伴生类</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> name = <span class="hljs-string">&quot;Jacky&quot;</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">val</span> age = <span class="hljs-number">20</span><br><br>  <span class="hljs-comment">// 访问伴生对象的私有方法</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sum</span></span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>) = <span class="hljs-type">Person</span>.add(x, y)<br>&#125;<br><br><span class="hljs-comment">//伴生对象</span><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">Person</span> </span>&#123;<br>  <span class="hljs-keyword">val</span> param = <span class="hljs-string">&quot;100&quot;</span><br><br>  <span class="hljs-keyword">private</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add</span></span>(x: <span class="hljs-type">Int</span>, y: <span class="hljs-type">Int</span>) = x + y<br><br>  <span class="hljs-comment">// 通过 伴生对象，访问 伴生类 的私有成员 时，必须要有 伴生类的对象</span><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">printAge</span> </span>= println(<span class="hljs-string">s&quot;age=<span class="hljs-subst">$&#123;new Person().age&#125;</span>&quot;</span>)<br><br>  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply</span></span>(): <span class="hljs-type">Person</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">Person</span>()<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><p>与伴生类不共享相同名称的单例对象称为独立对象。</p><p>转载自：</p><p><a href="https://www.w3cschool.cn/scala/scala-companion-objects.html">https://www.w3cschool.cn/scala/scala-companion-objects.html</a><br><a href="https://www.jianshu.com/p/26bd596090f6">https://www.jianshu.com/p/26bd596090f6</a></p>]]></content>
    
    
    <categories>
      
      <category>Scala学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Scala 样例类case class使用</title>
    <link href="/2022/11/19/Scala-%E6%A0%B7%E4%BE%8B%E7%B1%BBcase-class%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/11/19/Scala-%E6%A0%B7%E4%BE%8B%E7%B1%BBcase-class%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>Case Class是一种可以用来快速保存数据的类。自带以下方法：</p><ul><li>apply（由于其存在所以不需要new）</li><li>toString</li><li>equals</li><li>hashCode</li><li>copy<br>注⚠️：其默认是public的，且不能被<strong>继承</strong>。</li></ul><h1 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h1><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs Scala"><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">main</span></span>(args: <span class="hljs-type">Array</span>[<span class="hljs-type">String</span>]): <span class="hljs-type">Unit</span> = &#123;<br>        <span class="hljs-comment">// 使用样例类</span><br>        <span class="hljs-keyword">val</span> person = user(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-number">11</span>)<br>        <span class="hljs-comment">// 使用fun方法解构刚刚创建的对象的数据内容</span><br>        <span class="hljs-keyword">val</span> temp = fun.unapply(person)<br>        println(<span class="hljs-string">&quot;name：&quot;</span> + temp.get._1 + <span class="hljs-string">&quot;\r\n&quot;</span> + <span class="hljs-string">&quot;age：&quot;</span> + temp.get._2)<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">object</span> <span class="hljs-title">fun</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">unapply</span></span>(user: user): <span class="hljs-type">Option</span>[(<span class="hljs-type">String</span>, <span class="hljs-type">Int</span>)] = &#123;<br>        println(<span class="hljs-string">&quot;------调用unapply方法------&quot;</span>)<br>        <span class="hljs-type">Some</span>(user.name, user.age)<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 定义样例类</span><br><span class="hljs-keyword">case</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">user</span>(<span class="hljs-params">name: <span class="hljs-type">String</span>, age: <span class="hljs-type">Int</span></span>)</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Scala学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Scala</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISC-V特权指令集CSR寄存器初探</title>
    <link href="/2022/10/24/RISC-V%E7%89%B9%E6%9D%83%E6%8C%87%E4%BB%A4%E9%9B%86CSR%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%9D%E6%8E%A2/"/>
    <url>/2022/10/24/RISC-V%E7%89%B9%E6%9D%83%E6%8C%87%E4%BB%A4%E9%9B%86CSR%E5%AF%84%E5%AD%98%E5%99%A8%E5%88%9D%E6%8E%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h1><ul><li>CSR[11:0] encoding space</li><li>CSR[11:8] 解码 读写</li><li>non-existent CSR raise an illegal instruction exception.</li><li>Attempts to access a<br>CSR without appropriate privilege level or to write a read-only register also raise illegal instruction exceptions.</li><li>A read&#x2F;write register might also contain some bits that are read-only, in which case writes to the read-only bits <strong>are ignored</strong></li></ul><h1 id="确定需要基本支持的寄存器"><a href="#确定需要基本支持的寄存器" class="headerlink" title="确定需要基本支持的寄存器"></a>确定需要基本支持的寄存器</h1><p>以下寄存器在NutShell中均进行实现</p><h2 id="S-Mode"><a href="#S-Mode" class="headerlink" title="S Mode"></a>S Mode</h2><ol><li>Sstatus    2. Sedeleg    3. Sideleg   4. Sie</li><li>Stvec      6. Scounteren 7. Sscratch  8. Sepc</li><li>Scause     10. Stval     11. Sip      12. Satp</li></ol><h2 id="M-Mode"><a href="#M-Mode" class="headerlink" title="M Mode"></a>M Mode</h2><ol><li>Mvendorid  2. Marchid    3. Mimpid    4. Mhartid</li><li>Mstatus    6. Misa       7. Medeleg   8.Mideleg    </li><li>Mie        10. Mtvec     11. Mcounteren</li><li>Mscratch  13. Mepc      14. Mcause   15. Mtval</li><li>Mip</li></ol><h1 id="从M部分寄存器讲起"><a href="#从M部分寄存器讲起" class="headerlink" title="从M部分寄存器讲起"></a>从M部分寄存器讲起</h1><h2 id="WARL"><a href="#WARL" class="headerlink" title="WARL"></a>WARL</h2><p>P12<br>原文：<br>Some read&#x2F;write CSR fields are only defined for a subset of bit encodings, but allow any value to be written while guaranteeing to return a legal value whenever read. Assuming that writing the CSR has no other side effects, the range of supported values can be determined by attempting to write a desired setting then reading to see if the value was retained. These fields are labeled WARL in the register descriptions.</p><p>Implementations will not raise an exception on writes of unsupported values to a WARL field. Implementations can return any legal value on the read of a WARL field when the last write was of an illegal value, but the legal value returned should deterministically depend on the illegal written value and the architectural state of the hart.</p><h2 id="Machine-ISA-Register-misa"><a href="#Machine-ISA-Register-misa" class="headerlink" title="Machine ISA Register(misa)"></a>Machine ISA Register(misa)</h2><p>Volume2, P32<br>用于当前支持的RISC-V子集的配置信息</p><h2 id="Machine-Vendor-ID-Register-mvendorid"><a href="#Machine-Vendor-ID-Register-mvendorid" class="headerlink" title="Machine Vendor ID Register(mvendorid)"></a>Machine Vendor ID Register(mvendorid)</h2><p>产品供应商的ID，可以设置非商用</p><h2 id="Machine-Implementation-ID-Register-mimpid"><a href="#Machine-Implementation-ID-Register-mimpid" class="headerlink" title="Machine Implementation ID Register(mimpid)"></a>Machine Implementation ID Register(mimpid)</h2><p>提供处理器实现版本的唯一编码</p><h2 id="Hart-ID-Register-mhartid"><a href="#Hart-ID-Register-mhartid" class="headerlink" title="Hart ID Register(mhartid)"></a>Hart ID Register(mhartid)</h2><p>硬件级线程区分相关<br>关于Hart缩写的解释：<br>HARdware Thread<br>详见：<a href="https://groups.google.com/a/groups.riscv.org/g/sw-dev/c/QKjUDjz_vKo">https://groups.google.com/a/groups.riscv.org/g/sw-dev/c/QKjUDjz_vKo</a></p>]]></content>
    
    
    <categories>
      
      <category>体系结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISC-V</tag>
      
      <tag>CSR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Verilog小电路除法器设计</title>
    <link href="/2022/10/22/Verilog%E5%B0%8F%E7%94%B5%E8%B7%AF%E9%99%A4%E6%B3%95%E5%99%A8%E8%AE%BE%E8%AE%A1/"/>
    <url>/2022/10/22/Verilog%E5%B0%8F%E7%94%B5%E8%B7%AF%E9%99%A4%E6%B3%95%E5%99%A8%E8%AE%BE%E8%AE%A1/</url>
    
    <content type="html"><![CDATA[<figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs Verilog"><span class="hljs-keyword">module</span> Non_restoring_Divider<br>#(<span class="hljs-keyword">parameter</span> N = <span class="hljs-number">4</span>)<br>(<br><span class="hljs-keyword">input</span>    [<span class="hljs-number">2</span> * N-<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] dividend_i,<br><span class="hljs-keyword">input</span>    [N-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] divisor_i,<br><span class="hljs-keyword">output</span>  [N-<span class="hljs-number">1</span>:<span class="hljs-number">0</span>] quotient_o,<br><span class="hljs-keyword">output</span>  [<span class="hljs-number">2</span> * N-<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] remainder_o<br>);<br><br><span class="hljs-keyword">genvar</span> i;<br><br><span class="hljs-comment">// reg  [2 * N-2:0] tempR [N:0];</span><br><span class="hljs-keyword">logic</span>  [<span class="hljs-number">2</span> * N-<span class="hljs-number">2</span>:<span class="hljs-number">0</span>] tempR [N:<span class="hljs-number">0</span>];<br><span class="hljs-keyword">assign</span> tempR[<span class="hljs-number">0</span>] = dividend_i;<br><span class="hljs-keyword">assign</span> tempR[<span class="hljs-number">1</span>] = tempR[<span class="hljs-number">0</span>] - (divisor_i &lt;&lt; (N-<span class="hljs-number">1</span>));<br><span class="hljs-keyword">assign</span> quotient_o[N-<span class="hljs-number">1</span>] = (tempR[<span class="hljs-number">1</span>][<span class="hljs-number">2</span> * N-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] == <span class="hljs-number">1&#x27;b1</span>) ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br><br><span class="hljs-keyword">generate</span><br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">2</span>; i &lt;= N; i=i+<span class="hljs-number">1</span>) <span class="hljs-keyword">begin</span>:shift_and_calculate_result<br><span class="hljs-keyword">assign</span> tempR[i] = tempR[i-<span class="hljs-number">1</span>][<span class="hljs-number">2</span> * N-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] == <span class="hljs-number">1</span> ? (tempR[i-<span class="hljs-number">1</span>] + (divisor_i &lt;&lt; (N-i))) : (tempR[i-<span class="hljs-number">1</span>] - (divisor_i &lt;&lt; (N-i)));<br><span class="hljs-keyword">assign</span> quotient_o[N-i] = tempR[i][<span class="hljs-number">2</span> * N-<span class="hljs-number">2</span>-<span class="hljs-number">1</span>] == <span class="hljs-number">1</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br><span class="hljs-keyword">end</span><br><span class="hljs-keyword">endgenerate</span><br><br><span class="hljs-keyword">assign</span> remainder_o = tempR[N] + (<span class="hljs-number">1</span> - quotient_o[<span class="hljs-number">0</span>]) * divisor_i;<br><span class="hljs-keyword">endmodule</span><br></code></pre></td></tr></table></figure><p>Verilator:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;verilated_vcd_c.h&quot;</span> <span class="hljs-comment">//可选，如果要导出vcd则需要加上</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;VNon_restoring_Divider.h&quot;</span></span><br> <br><span class="hljs-type">vluint64_t</span> main_time = <span class="hljs-number">0</span>;  <span class="hljs-comment">//initial 仿真时间</span><br> VNon_restoring_Divider *top = <span class="hljs-keyword">new</span> <span class="hljs-built_in">VNon_restoring_Divider</span>(<span class="hljs-string">&quot;top&quot;</span>); <span class="hljs-comment">//调用VNon_restoring_Divider.h里面的IO struct</span><br><span class="hljs-function"><span class="hljs-type">double</span> <span class="hljs-title">sc_time_stamp</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> main_time;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span></span><br><span class="hljs-function"></span>&#123;<br>    Verilated::<span class="hljs-built_in">commandArgs</span>(argc, argv); <br>    Verilated::<span class="hljs-built_in">traceEverOn</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">//导出vcd波形需要加此语句</span><br> <br>    VerilatedVcdC* tfp = <span class="hljs-keyword">new</span> VerilatedVcdC; <span class="hljs-comment">//导出vcd波形需要加此语句</span><br>    top-&gt;<span class="hljs-built_in">trace</span>(tfp, <span class="hljs-number">0</span>);   <br>    tfp-&gt;<span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;wave2.vcd&quot;</span>); <span class="hljs-comment">//打开vcd</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">sc_time_stamp</span>() &lt; <span class="hljs-number">5</span> &amp;&amp; !Verilated::<span class="hljs-built_in">gotFinish</span>()) &#123; <span class="hljs-comment">//控制仿真时间</span><br>        top-&gt;dividend_i = <span class="hljs-number">15</span> + <span class="hljs-built_in">sc_time_stamp</span>();<br>        top-&gt;divisor_i = <span class="hljs-number">3</span>;<br>        top-&gt;<span class="hljs-built_in">eval</span>(); <span class="hljs-comment">//计算输出</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Quotient:%d Remainder:%d\n&quot;</span>, top-&gt;quotient_o, top-&gt;remainder_o);<br>        tfp-&gt;<span class="hljs-built_in">dump</span>(main_time); <span class="hljs-comment">//dump wave</span><br>        main_time++; <span class="hljs-comment">//推动仿真时间</span><br>    &#125;<br>    top-&gt;<span class="hljs-built_in">final</span>();<br>    tfp-&gt;<span class="hljs-built_in">close</span>();<br>    <span class="hljs-keyword">delete</span> top;<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>Makefile</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs makefile"><span class="hljs-section">all:</span><br>@echo <span class="hljs-string">&quot;Write this Makefile by your self.&quot;</span><br>verilator -Wno-fatal Non_restoring_Divider.v main.c --top-module Non_restoring_Divider --cc --trace --exe<br>make -C obj_dir -f VNon_restoring_Divider.mk VNon_restoring_Divider<br>./obj_dir/VNon_restoring_Divider <br><br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>前端Vue构建时的一些名词解释</title>
    <link href="/2022/10/21/%E5%89%8D%E7%AB%AFVue%E6%9E%84%E5%BB%BA%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/"/>
    <url>/2022/10/21/%E5%89%8D%E7%AB%AFVue%E6%9E%84%E5%BB%BA%E6%97%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E5%90%8D%E8%AF%8D%E8%A7%A3%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<ul><li>Vite</li><li></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>HTTP知识学习(Header)</title>
    <link href="/2022/10/15/HTTP%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0-Header/"/>
    <url>/2022/10/15/HTTP%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0-Header/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP知识学习-Header"><a href="#HTTP知识学习-Header" class="headerlink" title="HTTP知识学习 Header"></a>HTTP知识学习 Header</h1><p>HTTP 缓存分为以下两种，两者都是通过 HTTP 响应头控制缓存。</p><ul><li>强制缓存</li><li>协商缓存</li></ul><h2 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h2><p>再次请求时无需再向服务器发送请求</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh">          client         server<br>GET /a.ab389z.js -------&gt;<br>                &lt;------- 200 OK<br>(再也不会发请求)<br></code></pre></td></tr></table></figure><h3 id="与之相关的-Response-Headers"><a href="#与之相关的-Response-Headers" class="headerlink" title="与之相关的 Response Headers"></a>与之相关的 Response Headers</h3><ul><li>Expires</li></ul><p><strong>使用绝对时间</strong>，且有固定的格式 <a href="https://tools.ietf.org/html/rfc822#section-5.1">https://tools.ietf.org/html/rfc822#section-5.1</a></p><ul><li>Cache-Control</li></ul><p>具有强大的缓存控制能力<br>其常用字段：</p><ol><li>no-cache，每次请求需要校验服务器资源的新鲜度</li><li>max-age&#x3D;31536000，浏览器在一年内都不需要向服务器请求资源</li></ol><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p>再次请求时，需要向服务器校验新鲜度，如果资源是新鲜的，返回<code>304</code>，从浏览器获取资源</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">           client         server<br>GET /a.js   -----------&gt;<br>                   &lt;----------- 200 OK<br>GET /a.js   -----------&gt;<br>                   &lt;----------- 304 Not Modified<br></code></pre></td></tr></table></figure><h3 id="与之相关的-Request-x2F-Response-Headers"><a href="#与之相关的-Request-x2F-Response-Headers" class="headerlink" title="与之相关的 Request&#x2F;Response Headers"></a>与之相关的 Request&#x2F;Response Headers</h3><ul><li><code>Last-Modified</code>&#x2F;<code>If-Modified-Since</code><ul><li>匹配 Response Header 的 <code>Last-Modified</code> 与 Request Header 的 <code>If-Modified-Since</code> 是否一致。</li></ul></li><li>Etag&#x2F;If-None-Match<ul><li>匹配 Response Header 的 <code>Etag</code> 与 Request Header 的 <code>If-None-Match</code> 是否一致。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>HTTP</tag>
      
      <tag>Header</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RISV-V下OpenXiangShan和NutShell开源处理器CSR部分差异初探</title>
    <link href="/2022/10/14/RISV-V%E4%B8%8BOpenXiangShan%E5%92%8CNutShell%E5%BC%80%E6%BA%90%E5%A4%84%E7%90%86%E5%99%A8CSR%E9%83%A8%E5%88%86%E5%B7%AE%E5%BC%82%E5%88%9D%E6%8E%A2/"/>
    <url>/2022/10/14/RISV-V%E4%B8%8BOpenXiangShan%E5%92%8CNutShell%E5%BC%80%E6%BA%90%E5%A4%84%E7%90%86%E5%99%A8CSR%E9%83%A8%E5%88%86%E5%B7%AE%E5%BC%82%E5%88%9D%E6%8E%A2/</url>
    
    <content type="html"><![CDATA[<p>OpenXiangShan和NutShell是当前较为热门且开源的<code>RISC-V</code>处理器，NutShell整体较为简单，为UCAS一生一芯项目的作品，本文的主要目的是分析NutShell和OpenXiangShan的CSR部分的区别。</p><p>主要分析和使用的是：</p><ul><li>The RISC-V Instruction Set Manual Volume I: Unprivileged ISA Document Version 20191213</li><li>The RISC-V Instruction Set Manual Volume II: Privileged Architecture Document Version 20211203</li></ul><p><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/06/16657477937212.jpg"><br>ZiCSR指令全部实现。当然这也是必须的。</p><h1 id="支持的CSR寄存器"><a href="#支持的CSR寄存器" class="headerlink" title="支持的CSR寄存器"></a>支持的CSR寄存器</h1><h2 id="NutShell"><a href="#NutShell" class="headerlink" title="NutShell"></a>NutShell</h2><p>NutShell 默认支持以下的 CSR 寄存器：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs txt"># U 模式(实际未实现)<br>1. Ustatus    2. Uie        3. Utvec     4. Uscratch<br>5. Uepc       6. Ucause     7. Utval     8. Uip<br># S 模式<br>1. Sstatus    2. Sedeleg    3. Sideleg   4. Sie<br>5. Stvec      6. Scounteren 7. Sscratch  8. Sepc<br>9. Scause     10. Stval     11. Sip      12. Satp<br># M 模式<br>1. Mvendorid  2. Marchid    3. Mimpid    4. Mhartid<br>5. Mstatus    6. Misa       7. Medeleg   8.Mideleg    9. Mie        10. Mtvec     11. Mcounteren<br>12. Mscratch  13. Mepc      14. Mcause   15. Mtval <br>16. Mip<br></code></pre></td></tr></table></figure><p>其中U模式在<code>The RISC-V Instruction Set Manual Volume I: Unprivileged ISA Document Version 20190608-Base-Ratified</code>中仍存在，在最新20211203已不存在。<br>且NutShell中并未实际实现。<br><img src="https://seddonblog.oss-ap-northeast-1.aliyuncs.com/2023/01/06/16659231096548.jpg"></p><h2 id="OpenXiangShan"><a href="#OpenXiangShan" class="headerlink" title="OpenXiangShan"></a>OpenXiangShan</h2><p>LJW：香山的CSR就是多了一些自定义的寄存器，手册要求必须实现的部分是一样的，要是图简单的话就在nutshell上搞就可以。</p><p>OpenXiangShan中期待实现的寄存器：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs txt"><br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-comment"># S 模式 </span><br><span class="hljs-number">1</span>. Sstatus    <span class="hljs-number">2</span>. Sedeleg(X) <span class="hljs-number">3</span>. Sideleg(X) <span class="hljs-number">4</span>. Sie<br><span class="hljs-number">5</span>. Stvec      <span class="hljs-number">6</span>. Scounteren <span class="hljs-number">7</span>. Sscratch   <span class="hljs-number">8</span>. Sepc<br><span class="hljs-number">9</span>. Scause     <span class="hljs-number">10</span>. Stval     <span class="hljs-number">11</span>. Sip       <span class="hljs-number">12</span>. Satp<br><span class="hljs-regexp">//</span><span class="hljs-number">1</span> ~ <span class="hljs-number">12</span> Supervisor Trap<br><span class="hljs-regexp">//</span> For DeBUG not found <span class="hljs-keyword">in</span> RISC-V<br>Sbpctl, Spfctl, Slvpredctl, Smblockctl, Srnctl, Scachebase, Sfetchctl, Sdsid<br><span class="hljs-comment"># M 模式 (Nearly the same as NutShell)</span><br><span class="hljs-regexp">//</span> Machine Information Registers<br><span class="hljs-number">1</span>. Mvendorid <span class="hljs-number">2</span>. Marchid <span class="hljs-number">3</span>. Mimpid <span class="hljs-number">4</span>. Mhartid <span class="hljs-number">5</span>. Mconfigptr(New)<br><span class="hljs-regexp">//</span> Machine Trap Setup<br><span class="hljs-number">6</span>. Mstatus <span class="hljs-number">7</span>. Misa <span class="hljs-number">8</span>. Medeleg <span class="hljs-number">9</span>. Mideleg <span class="hljs-number">10</span>. Mie <span class="hljs-number">11</span>. Mtvec <span class="hljs-number">12</span>. Mcounteren<br><span class="hljs-regexp">//</span> Machine Trap Handling<br><span class="hljs-number">13</span>. Mscratch <span class="hljs-number">14</span>. Mepc <span class="hljs-number">15</span>. Mcause <span class="hljs-number">16</span>. Mtval <span class="hljs-number">17</span>. Mip<br><span class="hljs-comment"># 其他较NutShell新增</span><br><span class="hljs-regexp">//</span> Unprivileged Floating-Point CSRs<br>Fflags, Frm, Fcsr<br><span class="hljs-regexp">//</span> Unprivileged Counter/Timers<br>Cycle, Instret, Hpmcounter3~Hpmcounter31<br><span class="hljs-regexp">//</span> Machine Memory Protection<br><span class="hljs-regexp">//</span> TBD<br>PmpcfgBase, PmpaddrBase, <br><span class="hljs-regexp">//</span> Machine level PMA<br>PmacfgBase<br>PmaaddrBase<span class="hljs-regexp">//</span> <span class="hljs-number">64</span> entry at most<br><span class="hljs-regexp">//</span> Machine Counter/Timers<br><span class="hljs-regexp">//</span> Currently, we uses perfcnt csr set instead of standard Machine Counter/Timers<br><span class="hljs-regexp">//</span> <span class="hljs-number">0</span>xB80 - <span class="hljs-number">0</span>x89F are also used as perfcnt csr<br>Mcycle, Minstret, Mhpmcounter3~Mhpmcounter31, Mcountinhibit, Mhpmevent3~Mhpmevent31<br><span class="hljs-regexp">//</span> Debug/Trace Registers (shared with Debug Mode) (not implemented)<br><span class="hljs-regexp">//</span> Trigger Registers<br>Tselect, Tdata1, Tdata2, Tinfo, Tcontrol<br><span class="hljs-regexp">//</span> Debug Mode Registers<br>DcsrDpc, Dscratch0, Dscratch1<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>体系结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>RISC-V</tag>
      
      <tag>CSR</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP知识学习(状态码)</title>
    <link href="/2022/10/14/HTTP%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0-%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <url>/2022/10/14/HTTP%E7%9F%A5%E8%AF%86%E5%AD%A6%E4%B9%A0-%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP知识学习"><a href="#HTTP知识学习" class="headerlink" title="HTTP知识学习"></a>HTTP知识学习</h1><h2 id="状态码-HTTP-20X"><a href="#状态码-HTTP-20X" class="headerlink" title="状态码 HTTP 20X"></a>状态码 HTTP 20X</h2><h3 id="200-OK"><a href="#200-OK" class="headerlink" title="200 OK"></a>200 OK</h3><p>请求成功，应用最为广泛</p><p>如果是<code>GET</code>请求的话，也代表着<strong>资源获取成功</strong></p><h3 id="201-Created"><a href="#201-Created" class="headerlink" title="201 Created"></a>201 Created</h3><p>一般在<code>POST</code>请求中使用，代表<strong>资源创建成功</strong></p><p>可以参考<a href="https://q.shanyue.tech/http/20x.html#_201-created">https://q.shanyue.tech/http/20x.html#_201-created</a><br>在<code>POST</code>请求后返回201</p><h3 id="204-No-Content"><a href="#204-No-Content" class="headerlink" title="204 No Content"></a>204 No Content</h3><p>No Content，即服务器不会发送响应体（Response Body）。</p><p>它有以下场景：</p><ol><li>PUT 请求，修改资源的某个状态，此时 204 代表修改成功，无需响应体。见 RFC7231之 204 状态码(opens new window)</li><li>DELETE&#x2F;OPTION 请求</li><li>打点 API</li></ol><h3 id="206-Partial-Content"><a href="#206-Partial-Content" class="headerlink" title="206 Partial Content"></a>206 Partial Content</h3><p>partial:部分的</p><p>当客户端指定 <code>Range</code> 范围请求头时，服务器端将会返回部分资源，即<code>Partial Content</code>，此时状态码为 206。</p><p>主要是在针对较大的音视频资源，使用206表示<strong>部分内容。</strong></p><h2 id="状态码-HTTP-30X"><a href="#状态码-HTTP-30X" class="headerlink" title="状态码 HTTP 30X"></a>状态码 HTTP 30X</h2><p>30X为重定向部分。</p><h3 id="301-Moved-Permanently"><a href="#301-Moved-Permanently" class="headerlink" title="301 Moved Permanently"></a>301 Moved Permanently</h3><p>永久重定向，<strong>该操作比较危险</strong>，需要谨慎操作：如果设置了301，但是一段时间后又想取消，但是浏览器中已经有了缓存，还是会重定向。</p><h3 id="302-Found"><a href="#302-Found" class="headerlink" title="302 Found"></a>302 Found</h3><p>临时重定向，但是会在重定向的时候改变 method：<strong>把 POST 改成 GET</strong>，于是有了 307。</p><h3 id="307-Temporary-Redirect"><a href="#307-Temporary-Redirect" class="headerlink" title="307 Temporary Redirect"></a>307 Temporary Redirect</h3><p>临时重定向，在重定向时不会改变 method。</p><h3 id="308-Permanent-Redirect"><a href="#308-Permanent-Redirect" class="headerlink" title="308 Permanent Redirect"></a>308 Permanent Redirect</h3><p>永久重定向，在重定向时不会改变 method。</p><h3 id="Location-Header"><a href="#Location-Header" class="headerlink" title="Location Header"></a>Location Header</h3><p>在HTTP重定向时，会使用<code>Location</code>响应头来指明重定向后的地址。HTTP的Header不区分大小写，因此以下的<code>location</code>与<code>Location</code>相同。</p><h3 id="Response-Body"><a href="#Response-Body" class="headerlink" title="Response Body"></a>Response Body</h3><p>301&#x2F;302&#x2F;307&#x2F;308 响应有 Response Body 吗？</p><p>有，如上示例，知乎的重定向就包含响应体。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># 知乎的响应体是一段文字</span><br>$ curl https://www.zhihu.com<br>Redirecting to &lt;a href=<span class="hljs-string">&quot;//www.zhihu.com/signin?next=%2F&quot;</span>&gt;//www.zhihu.com/signin?next=%2F&lt;/a&gt;.<br><br><span class="hljs-comment"># 可通过 content-length 响应头获取响应体的长度</span><br>$ curl -s --<span class="hljs-built_in">head</span> https://www.zhihu.com | grep content-length<br>content-length: 93<br></code></pre></td></tr></table></figure><h3 id="Client-and-follow-redirect"><a href="#Client-and-follow-redirect" class="headerlink" title="Client and follow redirect"></a>Client and follow redirect</h3><p>在客户端发送请求时，如果发现某网址经重定向，则可再次向重定向后的网址发送请求。一些 HTTP 客户端工具，则会自动集成该功能，比如 curl 通过 –location 即可。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ curl --<span class="hljs-built_in">head</span> --location https://zhihu.com<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>前端</tag>
      
      <tag>状态码</tag>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第一篇文章</title>
    <link href="/2022/10/14/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/"/>
    <url>/2022/10/14/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/</url>
    
    <content type="html"><![CDATA[<p>Hello, World!(Again)</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/10/14/hello-world/"/>
    <url>/2022/10/14/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
